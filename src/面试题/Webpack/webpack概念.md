# Webpack概念

Webpack是一个javascript静态模块打包器，用webpack处理应用程序时，它会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。

## 为什么需要Webpack

### 现代开发方式

随着web应用越来越复杂和庞大，通过直接编写javascript、css、html开发web应用的方式效率低下。

在使用如下开发方案提升编码效率时：

- 模块化方案
- 框架如React的JSX语法
- 语言新特性如ES6语法
- 其他语言如使用TypeScript开发
- sass等css拓展语言

源代码无法直接运行，必须把源代码转换成可以直接在浏览器环境下运行的代码。

这个时候就需要**构建/打包**工具。

### 现代构建/打包工具要求

构建就是把源代码转换成发布到线上可执行的JavaScrit、css、html代码，构建工具的职责包括如下内容：

- 代码转换：TypeScript编译成JavaScript、SCSS变异成CSS、ES6以上的语法编译到ES5等。
- 文件优化：压缩JS\CSS\HTML，压缩合并图片等。
- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
- 模块合并：在采用模块化的项目中会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。
- 自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器。
- 代码校验：代码被提交到仓库之前需要校验代码是否符合规范，以及单元测试是否通过
- 自动发布：更新完代码之后，自动构建出线上发布代码并传输给发布系统

构建是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂流程，解放前端生产力，专注于实现业务功能。

### Webpack优点

- 专注于模块化项目，能做到开箱即用，一步到位；
- 使用场景不限于web开发(electron、react-native等)
- 社区庞大，版本成熟，紧跟web发展引入新特性，能为大多数场景找到已有的开源拓展
- 良好的开发体验

### Webpack缺点

只能用于采用模块化开发的项目

## entry(入口)

指示webpack应该使用哪个模块来作为依赖图的开始。

## output(输出)

告诉webpack在那里输出它创建的bundles

## loader

loader能让webpack去处理那些非JavaScript文件，也就是对模块的源代码进行转换。loader可以将所有类型的文件转为webpack能够处理的有效模块，然后就可以利用webpack的打包能力，对它们进行处理。

- test属性：用于表示出应该被对应的loader进行转换的某个或某些文件
- use属性：表示进行转化的时候应该使用哪个loader
- 支持链式调用，一组链式的loader按相反的顺序执行，loader链中的第一个loader返回值给下一个loader，在最后一个loader，返回webpack所预期的JavaScript
- loader可以是同步的也可以是异步的
- loader能够产生额外的任意文件



## plugins

插件plugins在webpack中几乎被用来做转换以外的所有功能，plugins的功能范围包括打包优化、压缩、定义环境变量等，可以用来处理各种任务。通过在构建流程中注入钩子实现。

需要添加到plugins中，并通过new操作来创建一个实例。

plugin是一个具有apply属性的JavaScript对象，apply属性会被webpack compiler调用，并且compiler对象可在整个编译生命周期访问。



## DevServer

webpack提供的打包构建功能只是让我们能够打包一个在浏览器中可直接运行的文件，但在实际开发中我们还需要：

- 提供HTTP服务而不是使用本地文件预览
- 监听文件的变化并自动刷新页面，做到实时预览
- 支持Source Map，以方便调试。

### 实时预览

DevServer会启动一个HTTP服务器用于服务网页请求，同时会帮助我们启动Webpack，并接受Webpack发出的文件变更信号，通过WebSocket协议自动刷新网页做到实时预览，以提高我们的开发效率。

DevServer在启动后会一直在后台运行，并且把webpack打包生成的文件输出到内存中，内存速度比磁盘快，所以能最快速的响应文件变化等。

### 模块热替换HMR

除了通过刷新整个网页来实现实时预览，模块热替换可以做到在不重新加载整个页面的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览，相对于刷新整个网页的机制来说能提供更快的响应和更好的开发体验。

### 支持Source Map

在浏览器中运行的 JavaScript 代码都是编译器输出的代码，这些代码的可读性很差。如果在开发过程中遇到一个不知道原因的 Bug，则你可能需要通过断点调试去找出问题。 在编译后输出的代码上进行断点调试是一件辛苦和不优雅的事情，浏览器自带的调试工具可以通过Source Map映射代码，让我们在源代码上断点调试。Webpack支持Source Map，我们只需要在配置中配置特定的值，就会生成特定需求的Source Map，以方便我们进行调试，当然，越精准的source Map构建越慢。

## Webpack执行过程

Webpack启动后会从Entry里配置的Module开始递归分析Entry依赖的所有Module。每找到一个Module，就会根据配置的Loader去找出对应的转换规则，对Module进行转化后，再解析出当前Module依赖的Module，如此往复。这些模块会以Entry为单位进行分组，一个Entry和其所有依赖的Module被分到一个组也就是一个一个Chunk。最后Webpack会把所有Chunk转换成文件输出。在整个流程中Webpack会在恰当的时机执行Plugin里定义的逻辑。

