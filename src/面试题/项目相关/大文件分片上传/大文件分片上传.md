# 大文件分片上传

## 计算文件MD5

对文件进行MD5计算，用这个值来当签名判断文件是否上传过。

文件的MD5值只和他的二进制内容相关，和它的名称无关，所以相同的文件会有相同的MD5。

在项目中使用SparkMD5这个库来计算文件的MD5。

大文件直接计算MD5比较慢，通过使用`fileReader.readAsArrayBuffer`方法读取文件分片（如2MB/5MB等），在f`ileReader.onload`事件触发后加入到sparkMD5的实例中，当读取完整个文件后使用`spark.end()`计算整个文件的MD5。

### 使用web-worker优化

由于MD5是CPU密集型操作，在单线程的javascript运行机制下会阻塞页面的UI渲染造成卡顿，所以对于这种计算型的工作我们可以交给web-worker执行，通过`worker.onmessage`监听MD5计算进度及计算结果。

通过使用`worker-plugin`帮助我们打包worker文件为特定chunk以动态加载，并且可以以加载模块的方式进行文件导入。

## 分片上传

- 分片上传
- 断点续传
- 秒传
- 多线程上传
- 自动重传
- 手动暂停
- 特定分片多次上传失败自动暂停
- 多任务并行上传
- 错误捕获
- 验签-上传-合并自动执行
- 进度查看
- 离开提示

### 分片上传

当我们用传统form表单进行提交上传大文件或直接通过ajax上传大文件时，可能会被服务器拒绝，或者由于网络不稳定没有传完就中断，然后又要重头传过。

所以我们可以借助`Blob.prototype.slice(start,end)`对文件进行分片，这样灵活度更高，可以手动暂停，也不会因为网络问题失败而需要重新传输整个分片。

分片上传前先通过文件MD5查询文件是否上传过，有3中状态：

- 从未上传过
- 上传过，但还未合并
- 已上传，合并过

对于未上传过的情况我们直接从头开始切片上传，而对于上传过的，后台会返回以上传过的文件切片的序号，我们因此可以得出未上传过的文件切片的序号，然后开始上传。对于已上传过的，后台会返回对应的文件地址。

分片上传的每个请求中，我们要告诉后台当前请求所携带的：

- 二进制文件切片内容
- md5标志放到哪个文件夹
- 当前分片序号
- 分片大小(字节)
- 总片数

后台接收到请求后根据MD5查看是否存在对应文件夹，存在的话就放到里面并使用序号命名，否则新建一个以该MD5和分片大小命名的文件夹。

分片上传完毕后，我们发送合并合并请求，带上文件MD5、总片数和想要给文件命名的名称，告诉后台合并对应文件夹下的文件，后台查看对应文件夹下是否有相应数量的文件数量，如果相同则合并返回最终的文件地址。

### 断点续传

根据我们分片上传的设计，后台会将以上传的分片存储到以总文件MD5和分片大小命名的文件夹下，并以前端传给后台的分片序号进行命名。所以当我们用文件MD5进行是否已上传过的检测时，如果对应文件曾经上传过，则会返回已上传过的分片序号的数组，前端根据这个数组得出待上传的分片序号数组，接下来只上传这些序号的分片，以达到断点续传的目的。

有可能是刷新了浏览器、或者手动暂停了任务、或者失败次数过多自动暂停。

### 秒传

当使用文件MD5进行查询时，如果已上传过，则会返回文件URL，我们直接触发成功回调，造成“秒传”的感觉。

### 多线程上传

因为我们的分片上传是最后通过合并请求告诉后端进行合并的，所以我们的文件分片上传顺序并不影响，因此我们可以进行多线程上传，也就是并发上传，同时执行多个分片上传。

chrome浏览器对于同个域名下最多同时开启6个TCP连接。因此若当我们允许的并发上传数大于等于6时，由于ajax请求的优先级为High，所以在文件分片上传结束之前，会阻塞那些优先级低于High的请求。例如动态创建js标签插入body中请求js文件的优先级为Low，当我们在单页应用中进行页面跳转时请求对应的chunk.js文件就是通过这种方式请求的，因此会被阻塞而造成白屏。

所以在项目中一般设置并发上传数为4，以避免阻塞其他请求。

### 自动重传

对于每个分片，当失败时，自动重传当前失败的分片，直到成功为止(有失败上限)。

### 手动暂停

由于是分片上传的形式，所以我们可以手动暂停。在项目中使用axios进行发送http请求，在axios中的config选项中可以传入`cancelToken`来取消未完成的请求。

```javascript
const CancelToken = axios.CancelToken;
const source = CancelToken.source();
axios.post('/api/file/chunkUpload',payload,{
    cancelToken:source.token
})
//执行cancel取消请求，message选填
source.cancel('手动暂停')
```

而在axios中，可以使用同一个cancel token取消多个请求。

所以我们对于同一个文件上传任务的分片上传请求，传入相同的token，然后暴露一个调用取消函数的方法，以进行手动暂停。

**在取消请求后记得重新生成一个cancelToken，否则下次传入已被取消的token会直接取消请求。**

在手动暂停而导致请求失败的catch分支中，我们需要将被取消的请求分片序号unshift回待上传的分片序号数组中，以维护在前端感知的“待上传分片数组”。

请求被取消了，但是有可能请求已经成功了，但是在响应返回的过程中被取消，所以浏览器拦截该响应并报错，实际上该分片可能已经上传完了，我们在手动重启任务的时候会重新查一次文件的状态，到时候以查询返回结果为准。

### 特定分片多次上传失败自动暂停

我们在实现上是请求失败(报错)后会重新上传当前失败的分片，但有可能后台的文件上传服务挂了导致请求报错，所以我们不能无限制地重传。

在每个文件上传任务中，我们会维护一个Map实例，用于记录某个分片序号对应的失败次数，当失败次数小于最大失败上限次数时，会进行重传并将序号对应的失败次数加一。当特定分片序号到达最大失败上限次数时，不再进行重传，并自动调用取消请求的cancel函数。

在所有请求都停止后清空Map实例，以达到在重新开始前重置错误数量的目的。

### 多任务并行上传

因为在业务中，可能在上传的文件数不止一个，所以会有并发的多个不同文件同时上传。但由于在**多线程上传**中讲到的若分片上传请求的并发数大于等于6时，会阻塞其他低优先级的请求，所以我们在实现多个文件任务并行上传的同时，还要保证多个任务之间的总并发数4，也就保证了不会阻塞其他低优先级的请求。

除了不阻塞低优先级的请求之外，还要保证多个并行任务对于分片上传请求的均匀分布。如果一个文件上传任务A先于另一个文件上传任务B执行，有可能会一直霸占请求数，而任务B由于一开始没有获取到请求机会而停止，所以我们需要在每次一个文件上传任务的单个分片上传请求成功后，通知别的任务获取下一个请求上传的机会。

所以需要实现一个订阅发布机制，以在上传任务类的多个任务实例之间进行通信。

### 错误捕获

在检查文件MD5、上传分片、合并分片的三个阶段，都有可能发生报错，所以我们需要捕获这些错误。

在新建大文件上传任务时我们可以传递错误回调函数，以在发生错误时触发回调。

### 验签-上传-合并自动执行

由于检验MD5、分片上传、合并分片是大文件上传的连续流程，所以对于业务调用上传任务时，应该在任务中自动执行，调用方只需传递文件、md5、以及各种回调即可。

### 进度查看

分片上传我们可以根据 **已上传文件分片数/文件分片总数** 计算得出当前的进度。

**已上传分片总数 = 文件分片总数 - 待上传分片数 - 正在上传分片数量**



## 相关拓展

### 查看进度其他方案

axios的config中可以传`onUploadProgress`和`onDownProgress`分别监听当前请求的上传和下载进度。

监听回调的`event.loaded`代表 已上传/已下载 字节数，`event.total`代表 请求总大小/响应总大小。

回调的频率根据网络状况而定，网络状况好时每次回调都是`event.loaded===``event.total`所以还是用已上传分片数量比较直接。

### 原生AJAX进度

```javascript
const xhr = new XMLHttpReuest();
xhr.onprogress = function(e){}//监听下载进度
xhr.upload.onprogress = function(e){}//监听上传进度
```

### 原生AJAX取消请求

XMLHttpReuest实例对象上有个abort方法，调用之后就会取消请求。

但是这个请求是给客户端使用的，仅仅是对调用abort的请求进行拦截并报错，后端有可能已经接受并响应请求了。

### 离开提示

通过判断全局是否有上传任务执行中，有的话弹窗提示。

```javascript
//当有文件在上传时弹窗提示
window.addEventListener('beforeunload', e => {
  if (BigFileUploadClass.TOTAL_LOADING_COUNT !== 0) {
    e.returnValue = '有文件在上传噢';
    return '有文件在上传噢';
  }
});
```





## 细节

postmessage传输的数据都会通过序列化进行拷贝，所以不能序列化的数据会报错，比如有函数的对象。

postmessage传递基本类型时，会拷贝一份值，对于引用类型，会先序列化成字符串传递，worker接收到再进行反序列化成引用对象。

对于Transferable数据，可以通过第二个参数的数组传递那些共享引用的数据的引用，这样就不会发生拷贝，传递速度快了很多。