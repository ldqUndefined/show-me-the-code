# React常用优化手段

## 避免重新渲染

减少不必要的渲染时React组件性能优化最重要的方向。

### 减少自身渲染次数

类组件继承`PureComponent`或者实现`shouldComponentUpdate`，避免父组件重新渲染时引起自身不必要的渲染。函数组件使用`React.memo`进行包裹，相当于使用了以及函数对函数组件进行了记忆，默认对新props进行一次浅比较，相同时直接返回之前的结果，也可以自己实现第二个参数`isEqual`，返回`true`时不重新渲染。

### 减少子组件渲染次数

- 传递对象类型时尽量保证引用相等，不要传递如`<Child value={{age:'21'}} />`对象字面等每次引用不相等的值，造成子组件不必要的重新渲染。尽量使用类组件或者函数组件中的state传递，或者实在有需要可以在类组件使用记忆函数，或者在函数组件中使用`useMemo`保证引用相等
- 传递函数类型时应尽量避免使用箭头函数形式的事件处理器。`<Child onChange={()=>{console.log('no!!')}} />`，因为箭头函数在每次组件重新渲染时会重新创建，引用不同，也会造成子组件不必要的重新渲染。在类组件中建议传递类的实例函数，在函数组件中声明的处理函数应用`useCallback`包裹，以尽量不改变处理函数的引用。

### 合理拆分组件，控制渲染粒度

- 比如一个组件Component接收A,B,C三个props，当任何一个数据源发生变化时，都会引起组件的重新渲染。而组件Component中又是分为三个部分分别展示A、B、C数据。此时我们可以将该组件继续拆分，将渲染A数据的部分拆成一个组件，B和C同理。改造完成之后，当A数据发生变化而B、C数据没有发生变化时，只有渲染A数据的组件会发生重新渲染，而渲染B、C数据的组件不会引发重新渲染。
- 当列表渲染的每一项并不是简单的dom节点时，可以考虑将列表渲染的项抽成一个组件。否则当组件重新渲染时，列表里的每一项都会重新渲染，而当将列表项抽成一个组件时，只有数组中改变的项会受到影响，其他的项都不会重新渲染。

### 合理使用Context，避免所有子节点的重复渲染

Context是React提供的在组件树间进行数据传递的方法。但是不当得使用Context会严重影响应用的性能，引起不必要的渲染。

- 首先，当Context的Provicer的value发生变化时，所有订阅了该Provider的Consumer或者使用useContext订阅了该context的组件都会触发重新渲染，这个重新渲染不受制于`shouldComponentUpdate`和`React.memo`。不要传递如`<MyContext.Provide value={{age:12}}>`这种对象字面量，否则当包含`MyContext`的组件发生重新渲染时，value的引用会发生变化，从而导致所有订阅了该Context的组件重新渲染，所以需要对传递给value的值进行缓存，使用记忆函数、useMemo，或者直接传递state
- 合理拆分Context，当一个Context的value包含的值太多时，可能会有这种情况：当子组件Child订阅了一个Context，但又没有使用组件中的值如A时，但是由于A的变化，自身还是必须重新渲染，在这种情况下，我们可以：
  - 把Context按功能拆成多个，子组件根据自身需求订阅所需的Context，这样当与自己不想关的值发生变化时，自己也就不会触发重新渲染。
  - 创建另一个组件ChildOfCild，功能与Child相同，但是所需的值从props中获取，然后我们在Child中订阅该Context提取出自己需要的值，然后传递给ChildOfCild，这样即使context上和自己不相关的值发生变化，但是Child中提取出来的值不变，所以CildOfCild不会重新渲染，虽然这样Child还是重新渲染了，但导致的计算量变少了。
- Provider的设计使用render Props。当我们的组件Parent直接使用Context.Provider包裹子组件时，如果Provider发生重新渲染时，所有的子组件都会重新渲染(如果不使用shouldComponentUpdate之类的话)，这是我们不想看到的。所以我们应该把Provider单独封装成一个组件，通过props.children来渲染他下层的组件，这样当Provider重新渲染时，它下面的组件就不会引起重新渲染了，因为子组件们都是当做props传递进去的。

## 渲染方案

- 当数据量特别大导致需要渲染很多个dom结点时， 可以使用虚拟列表：只渲染当前视口可见的元素。
- 组件懒加载。避免加载当前页面未使用到的组件。



