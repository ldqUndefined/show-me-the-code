# 说说diff算法

计算一棵树形结构转换成另一颗树形结构的传统对比算法通过循环递归对结点进行一次比对，复杂度高达O(n三次方)，效率低下。

React中的diff是O(n)的，这是基于react的启发式算法，通过：

- ~~两个不同类型的元素会产生出不同的树~~
- ~~开发者可以通过 `key` prop 来暗示哪些子元素在不同的渲染下能保持稳定；~~

- 只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。

- 两个不同类型的元素会产生出不同的树。如果元素由`div`变为`p`，React会销毁`div`及其子孙节点，并新建`p`及其子孙节点。

- 开发者可以通过 `key`属性 来暗示哪些子元素在不同的渲染下能保持稳定。

对于数组项可以使用key进行标识，以复用元素，最小化真实dom的修改。

以上的三个策略是基于大部分场景下得出的具有普适性的策略，并不一定代表极端状况下的性能是最优的，比如我们会遇到跨层级的DOM移动操作，但是这在我们的大部分场景下不会遇到，React为了迎合大部分场景选择不考虑这样的情形。而对于同级diff在某些场景下也会出现类型发生变化，但是子集没有发生变化的情况，但是遇到的场景比较少，为了最优化常规情况下的更新，React选择采用了以上三种策略判断更新。

## 参考链接

[知乎diff](https://zhuanlan.zhihu.com/p/20346379)

