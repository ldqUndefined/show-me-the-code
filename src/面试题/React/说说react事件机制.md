# 说说react事件机制

当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发。

具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。我们在组件中事件触发时拿到的是**合成事件对象(SyntheticEvent)**而不是原始的DOM事件对象。

## 为什么要自定义一套事件系统

- 抹平浏览器之间的兼容性差异。
- 事件自定义。可以自定义高级事件，如React的onChange事件。
- 抽象跨平台事件机制。
- 可以做更多优化。利用事件委托，把大部分事件绑定到Document而不是DOM节点本身，简化了DOM事件处理逻辑，**减少内存开销**，一个类型的事件只注册一次。但React也需要自己模拟一套事件冒泡的机制
- React想要干预事件分发。这样就可以实现事件优先级。

## 流程

![react事件挂载](./图片/react事件挂载.PNG)

![react事件触发](./图片/react事件触发.PNG)

1. 首先在document上注册各种事件。其次在fiber生成或者更新的过程中，如果fiber的类型是dom内置类型如'div'等时，判断props上是否有事件类型，有的话将类型和对应的回调存起来。
2. 当有事件触发并冒泡到document时，开始事件的分发。根据事件原生对象找到事件触发节点，并根据当前事件类型合成对应的合成事件对象。根据事件触发节点一次找到其祖先类型为浏览器内置类型的fiber节点，按顺序找到并执行注册在捕获阶段的事件、注册在冒泡阶段的事件。

## 开发会遇到的问题

React组件上声明的时间没有绑定到React组件对应的原生DOM节点上。

由于React的事件委托机制，React组件对应的原生DOM节点上的事件触发时机总是在React组件上的事件之前。

原生事件阻止冒泡一定会阻止合成事件的触发，合成事件的阻止冒泡不会影响原生事件，只会阻止合成事件的冒泡。

## 如何解决父组件是原生事件绑定，子组件是React事件导致触发顺序不按我们意料的情况？

通过使用React.createPortal将React事件绑定的子组件，渲染到原生事件绑定的父组件的兄弟或者祖先节点上。就可以避免出现父组件的事件触发比子组件事件触发早的问题。

## React事件都是捕获-冒泡吗？

大部分事件都遵从捕获-冒泡的方式、并且默认都是冒泡阶段触发，如需在捕获阶段触发，可以加上Capture。

鼠标事件onMouseEnter和onMouseLeave事件从离开的元素向进入的元素传播，不是正常的冒泡，也没有捕获阶段。

指针事件onPointerEnter和onPointerLeave事件从离开的元素向进入的元素传布，不是正常的冒泡，也没有捕获阶段。













