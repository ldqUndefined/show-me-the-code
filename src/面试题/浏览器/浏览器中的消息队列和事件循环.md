# 浏览器中的消息队列和事件循环

JavaScript 是一门单线程非阻塞的脚本语言，这是设计之初就决定的。

假如JavaScript是多线程的话，那对于dom的操作可能会出现竞态，比如一个线程对dom添加事件，另一个线程删除了dom，那么改如何处理呢，为了不保证这样的情况发生，所以只采用一个线程执行代码，保证了操作结果的一致性，这可能是设计为单线程的考虑。

单线程意味着js代码在执行的过程中，就都只有一个主线程来处理所有的任务。

而非阻塞则是当代码需要执行异步任务的时候，比如发请求等，主线程会将这个任务挂起，当异步任务有结果返回的时候，再根据一定的规则去执行响应的回调。这里的非阻塞就是由事件循环实现的。



当执行js代码的时候，js引擎会对它进行编译并生成全局执行上下文，并压入执行栈中，在整个页面的声明周期中，只会有一份全局执行上下文。

执行同步代码的时候遇到函数时，会生成与这个方法对应的执行上下文并压入栈中，但执行完之后就会出栈。

当遇到异步代码时，js不会等待执行的结果，而是会将它交给对应的IO线程，等异步任务有结果之后再加入事件队列中，放入事件队列的任务不会立即执行，而是等待当前执行栈中的所有任务都执行完毕后，主线程会去查看事件队列中是否有任务，如果有就把这个事件对应的回调放入执行栈中，然后执行回调中的同步代码，如此往复，形成了一个循环，就是事件循环。

而在事件队列中的任务我们称为宏任务，与此对应的还有微任务。

宏任务有：

- setTimeout
- setInterval

微任务有：

- Promise
- MutationOserver

在每个宏任务的执行过程中，会维护一个微任务队列，在当前的宏任务快要执行完成时，会去查看对应的微任务队列是否有任务，如果有，则依次执行对应的回调函数，直到微任务队列为空，在这个任务过程中产生的微任务都会添加到该宏任务的微任务队列中，当微任务为空时，再去宏任务队列中去获取下一个任务，如此往复。







