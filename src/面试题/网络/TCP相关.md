# TCP相关

## TCP和UDP的区别

**TCP是一个面向连接的、可靠的、基于字节流的传输层协议。**

**UDP是一个面向无连接的传输层协议**



TCP是可靠的，UDP是尽力而为的

在对系统资源的要求上：TCP要求多，UDP要求少

报文结构：TCP复杂，UDP简单

TCP保证顺序，UDP不保证

TCP是面向连接的，所以一次只能向一台机器发送报文，而UDP是无连接的，可以同时向多台机器发送同样的报文

TCP有拥塞控制，UDP没有

TCP头部大(20字节)，UDP头部小(8字节)

TCP是面向字节流的，UDP是面向报文的(应用层的数据加个UDP头就传给IP层了)



**应用场景：**

TCP适用于可靠性要求高

UDP适用于实时性要求高，有少量丢包无所谓的场景。



## 讲讲TCP三次握手

### 三次握手的目的

握手的意义是为了确认双方的两种能力：**发送的能力** 和 **接收的能力**

![三次握手](./图片/三次握手.png)



第一次握手：客户端发起SYN，自己从CLOSED变成SYN-SENT，服务端收到，因此服务端确定了客户端有**发送的能力**。

第二次握手：服务端收到SYN之后，返回SYN和ACK，自己变成SYN-RCVD状态。

第三次握手：客户端收到服务端返回的SYN和ACK，证明了服务端有**发送的能力**和**接收的能力**，于是发送ACK给服务端，自己变成ESTABLISHED状态，服务端收到客户端的ACK之后得知了客户端有**接收的能力**，也变成ESTABLISHED，握手结束。

三次握手客服端和服务端各自证明了对方有发送的能力和接收的能力。

**凡是需要对端确认的，一定消耗TCP报文的序列号。**

SYN需要对端的确认，而ACK不用，所以SYN消耗一个序列号而ACK不需要。



### 为什么不是两次

根本原因：无法确认客户端的接收能力。

如果是两次握手，假设发送了一个SYN报文向握手，但是报文由于网络原因直流在网络链路中阻塞没有到达，TCP认为是丢包而进行重传，重传的包到达后服务器响应成功握手建立起了连接，如果这次连接传输完之后关闭了连接之后，滞留的那个包又到达了服务器，这个服务器接收到，误以为客户端想建立连接，因为是两次握手，服务端接收并确认之后建立起连接，但是客户端此时已经断开了，所以会导致服务器一直在等待造成浪费资源的情况。



### 为什么不是四次

三次握手的目的是确定双方具有发送和接收的能力，三次握手已经能够达成这个目的，这个时候再增加握手次数也没有太大意义了，只会浪费资源和增加通信时间。



### 三次握手中可以携带数据吗

前两次握手不能携带，第三次握手可以携带。

如果前两次握手可以携带数据，那么如果有人想攻击服务器的话，他只需要在第一次握手中的SYN报文中放大量的数据，这个时候服务器就会消耗很多的时间和内存去处理数据，增加了服务器被攻击的风险。

第三次握手的时候，客户端已经处于ESTABLISHED状态了，并且客户端已经确认了服务端的接收和发送的能力，这个时候就相对安全可言携带数据了。

### 两端同时打开会怎样？(同时发送SYN报文)

双方同时发送SYN报文的情况是可能发生的情况：

![同时SYN](./图片/同时SYN.png)

发完SYN，两者状态都变成SYN-SENT

收到对方的SYN后，两者都变成了SYN-REVD

接着回复SYN+ACK，在对方接收到这个报文后会变为ESTABLISHED。

这就是同时打开情况下的状态变迁，由TCP握手的状态机决定。

## 讲讲TCP四次挥手

![四次挥手](./图片/四次挥手.PNG)

刚开始双方处于ESTABLISHED状态。

客户端要断开，向服务器发送FIN报文，发送后客户端进入FIN-WAIT-1状态，这个时候客户端处于half-close(半关闭)状态，**无法向服务器发送报文，只能接受**

服务器接收后想客户端发出确认，变成CLOSE-WAIT状态。

客户端接收到服务端的确认后，变成FIN-WAIT2状态。

随后服务端向客户端发送FIN，进入LAST-ACK状态。

客户端收到来自服务端发送的FIN后，自己变成了TIME-WAIT状态，然后发送ACK给服务端。

这个时候客户端需要等待足够的时间，等待时长为**2个MSL**(Maximum Segment Lifetime，报文最大生存时间)，在这段时间内如果没有收到服务端的重发请求，那么表示ACK成功到达，挥手结束，否则重发ACK。

### 为什么要等待2MSL

如果不等待会怎么样？

在服务器端收到客户端第一个Fin并发出Ack的时候，此时服务端可能还有数据没发完，等到发完了，服务器端才会发出FIN进入Last-Ack阶段，此时，如果发送的数据报文由于网络阻塞，导致比Fin报文晚到达的话，如果客户端收到服务端的FIN补等待直接关闭连接的话，会导致客户端没有收到本该收到的报文，此时如果客户端的端口又被新的应用占用的话，会导致接收到很多无用数据包，造成数据包混乱。所以为了保险需要等到服务器发来的数据包都被当前应用收到或者都在路上丢失了再关闭。

上面的等待理论上只需要等待1个MSL就可以了，为什么要等待2个MSL呢？

- 1个MSL确保四次挥手中主动关闭放最后的ACK报文最终能到达对方
- 1个MSL确保对方没有收到ACK而超时重传的FIN报文可以到达

极限情况下就是在接近1个MSL的时候对方重传一个FIN过来，所以是2个MSL。

### 为什么是四次挥手而不是三次

服务端在收到FIN后，可能还在发送报文，所以需要等报文处理完之后才发送自己也能关闭的FIN，因此会先发送一个ACK告诉客户端自己已经收到了对方的FIN了，然后等处理完所有报文之后再发送FIN，告诉对方自己可以关闭了。这就是需要四次握手的原因。

如果是三次握手的话，相当于服务端再接收到客户端的FIN后，把ACK和FIN都发送回给客户端，这个时候如果之前的报文处理时间过长，导致迟迟没有发出FIN/ACK的报文的话，客户端会误以为自己的FIN没有到达对方而不断重发FIN。

### 同时关闭会怎样

![同时FIN](./图片/同时FIN.png)

其实也是由自动状态机决定的，我们正常的握手和挥手都是理想状态，但是协议的制定人已经帮我们考虑好了，所以我们看到的握手和挥手的状态机每个状态都会有我们比较少见的入和出状态转移。



## TCP握手攻击





